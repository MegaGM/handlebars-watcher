#!/usr/bin/env node

'use strict'

/* ================================================
 * Meow! :3
 * ===============================================*/
const
  colors = require('colors'),
  fs = require('fs-extra'),
  path = require('path'),
  resolve = path.resolve,
  packageJson = require(resolve(__dirname, '../package.json'))
let
  cwd = process.cwd(),
  config = {
    appName: 'Handlebars Builder:'.yellow,
    filename: 'handlebars.config.js',
    filepath: null,
    appIsReady: false,
    howto: '\nRead howto: https://github.com/MegaGM/ya-handlebars-bundler#readme',
    init() {
      this.filepath = resolve(cwd, this.filename)
      delete this.init
      return this
    },
  }.init(),
  howto = config.howto,
  cc = null // clientConfig

/**
 * check if there is ${config.filename} file in cwd
 */
try {
  cc = require(config.filepath)
} catch (err) {
  if ('MODULE_NOT_FOUND' === err.code)
    return showError(`There is no ${config.filename.red} in this directory! ${howto}`)

  showError('Unhandled exception O_o'.red)
  throw err
}

/**
 * ^,..,^
 */
global.config = config // to use in hash.js

{ // clientConfig scope
  /**
   * deal with clientConfig.entry
   */
  let
    e = cc.entry,
    ce = 'config[\'entry\']'.red
  if (!e)
    return showError(`${ce} MUST be presented in ${config.filename.red} ${howto}`)

  if (!e.helpers && !e.partials && !e.templates)
    return showError(`${ce} MUST contain at least one of the props: helpers, partials, teamplates ${howto}`)

  // resolve abs paths
  e.helpers = e.helpers ? resolve(cwd, e.helpers) : null
  e.partials = e.partials ? resolve(cwd, e.partials) : null
  e.templates = e.templates ? resolve(cwd, e.templates) : null

  /**
   * deal with clientConfig.output
   */
  let
    o = cc.output,
    co = 'config[\'output\']'.red
  if (!o)
    return showError(`${co} MUST be presented in ${config.filename.red} ${howto}`)

  if (!o.path || !o.filename)
    return showError(`${co} MUST contain: path, filename ${howto}`)

  // filename.js => filename
  o.filename = o.filename.replace(/\.js$/i, '')
  // filename => filename[.min].js
  o.filename = o.filename + (o.minify ? '.min' : '') + '.js'

  o.bundleFilepath = resolve(cwd, o.path, o.filename)

  /**
   * merge clientConfig into config
   */
  config = Object.assign(config, cc)
} // clientConfig scope

/**
 * create all the directories just in case :D
 */
let shouldExist = [
  config.output.path,
]

shouldExist.forEach(dir => {
  try {
    fs.ensureDirSync(dir)
  } catch (err) {
    showError('error while creating directory: '.red, dir)
    throw err
  }
})

/* ================================================
 * Start its job!
 + instanciate Hash
 + setup Watcher
 + on changes: update Hash, bundle entire hash, minify and write
 * ===============================================*/
const
  chokidar = require('chokidar')
let
  hash = require('./hash'),
  watcherDirs = [config.filepath],
  watcherOptions = { ignored: /[\/\\]\./i }

for (let d in config.entry)
  watcherDirs.push(d)

let watcher = chokidar.watch(watcherDirs, watcherOptions)

// add files on startup
watcher.on('add', filepath => {
  if (filepath === config.filepath) return // ignore handlebars.config.js

  let file = hash.add(filepath)
  if (!file)
    return showError('Something went wrong while adding:'.red + '\n' +
      filepath + '\nThe file has not been added due to some errors!')

  if (config.appIsReady)
    hash.updateBundle()

  showInfo('added', path.join(file.relativeDir, file.base))
})

watcher.on('ready', () => {
  config.appIsReady = true
  console.info()
  showInfo('v.'.yellow + packageJson.version.yellow + ' monitoring is active! ^_^')

  // concat entire hash, minify, write to disk
  hash.updateBundle()

  watcher.on('change', filepath => {
    if (filepath === config.filepath)
      return showError(`Configuration file ${config.filename} has been changed, `.red + 'please restart the application!')

    let file = hash.update(filepath)
    if (!file)
      return showError('Something went wrong while updating: \n'.red + filepath + '\nThe file has not been updated due some errors!')

    showInfo('updated'.cyan + path.join(file.relativeDir, file.base))
    hash.updateBundle()
  })

  watcher.on('unlink', filepath => {
    if (filepath === config.filepath)
      return showError('Configuration file has been deleted, '.red + 'please give it back to me :\'('.cyan)

    let file = hash.remove(filepath)
    if (!file)
      return showError('Something went wrong while removing: \n'.red + filepath + '\nThe file has not been removed due to some errors!')

    showInfo('removed'.red + path.join(file.relativeDir, file.base))
    hash.updateBundle()
  })

  watcher.on('addDir', dir => {
    showInfo('added'.yellow, dir)
    watcher.add(dir)
  })

  watcher.on('unlinkDir', dir => {
    showInfo('removed'.red + dir.replace(cwd, ''))
    watcher.unwatch(dir)
  })
})

function showError(message) {
  return console.error(config.appName, message)
}

function showInfo(message) {
  return console.info(config.appName, message)
}
